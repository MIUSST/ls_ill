@cindex standards conformance, ANSI C
@cindex ANSI C, use of
@cindex C extensions, compatible use of
@cindex compatibility
This chapter describes how to compile programs that use OOL, and
introduces its conventions.

@menu
* ANSI C Compliance::
* Compiling and Linking::
* Shared Libraries::
* Compatibility with C++::
* Aliasing of arrays::
* Thread-safety::
@end menu

@node ANSI C Compliance
@section ANSI C Compliance

The library is written in ANSI C and is intended to conform to the ANSI
C standard.  It should be portable to any system with a working ANSI C
compiler.

The library does not rely on any non-ANSI extensions in the interface it
exports to the user. Programs you write using OOL can be ANSI
compliant.  Extensions which can be used in a way compatible with pure
ANSI C are supported, however, via conditional compilation.  This allows
the library to take advantage of compiler extensions on those platforms
which support them.

When an ANSI C feature is known to be broken on a particular system the
library will exclude any related functions at compile-time.  This should
make it impossible to link a program that would use these functions and
give incorrect results.

To avoid namespace conflicts all exported function names and variables
have the prefix @code{ool_}, while exported macros have the prefix
@code{OOL_}.

@node Compiling and Linking
@section Compiling and Linking
@cindex compiling programs, include paths
@cindex including OOL header files
@cindex header files, including
The library header files are installed in their own @file{ool}
directory.  You should write any preprocessor include statements with a
@file{ool/} directory prefix thus,

@example
#include <ool/ool_conmin.h>
@end example

@noindent
If the directory is not installed on the standard search path of your
compiler you will also need to provide its location to the preprocessor
as a command line flag.  The default location of the @file{ool}
directory is @file{/usr/local/include/ool}.  A typical compilation
command for a source file @file{example.c} with the GNU C compiler
@code{gcc} is,
@example
gcc -I/usr/local/include -c example.c
@end example
@noindent
This results in an object file @file{example.o}.   The default
include path for @code{gcc} searches @file{/usr/local/include} automatically so
the @code{-I} option can be omitted when OOL is installed in its default
location.

@cindex compiling programs, library paths
@cindex linking with OOL libraries
@cindex libraries, linking with
The library is installed as a single file, @file{libool.a}.  A shared
version of the library is also installed on systems that support
shared libraries.  The default location of these files is
@file{/usr/local/lib}. To link against the library you need to specify
not only the main library, but also the GSL library, which is required
by OOL, and a supporting @sc{cblas} library, which provides standard
basic linear algebra subroutines.  A suitable @sc{cblas}
implementation is provided in the library @file{libgslcblas.a} if your
system does not provide one.  The following example shows how to link
an application with the library,

@example
gcc example.o -lool -lgsl -lgslcblas -lm
@end example
@noindent
The following command line shows how you would link the same application
with an alternative blas library called @file{libcblas},

@example
gcc example.o -lool -lgsl -lcblas -lm
@end example
@noindent
For the best performance an optimized platform-specific @sc{cblas}
library should be used for @code{-lcblas}.  The library must conform to
the @sc{cblas} standard.  The @sc{atlas} package provides a portable
high-performance @sc{blas} library with a @sc{cblas} interface.  It is
free software and should be installed for any work requiring fast vector
and matrix operations.  The following command line will link with the
@sc{atlas} library and its @sc{cblas} interface,

@example
gcc example.o -lool -lgsl -lcblas -latlas -lm
@end example
@noindent
For more information see ``BLAS Support'' chapter in the GSL documentation.

The program @code{ool-config} provides information on the local version
of the library.  For example, the following command shows that the
library has been installed under the directory @file{/usr/local},

@example
bash$ ool-config --prefix
/usr/local
@end example
@noindent
Further information is available using the command @code{ool-config --help}.

@node Shared Libraries
@section Shared Libraries
@cindex shared libraries
@cindex libraries, shared
@cindex LD_LIBRARY_PATH
To run a program linked with the shared version of the library it may be
necessary to define the shell variable @code{LD_LIBRARY_PATH} to include
the directory where the library is installed.  For example, in the
Bourne shell (@code{/bin/sh} or @code{/bin/bash}), the library path can be set
with the following commands:

@example
LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH
export LD_LIBRARY_PATH
./example
@end example
@noindent
In the C-shell (@code{/bin/csh} or @code{/bin/tcsh}) the equivalent
command is,

@example
setenv LD_LIBRARY_PATH /usr/local/lib:$LD_LIBRARY_PATH
@end example

To save retyping these commands each session they should be placed in an
individual or system-wide login file.

To compile a statically linked version of the program, use the
@code{-static} flag in @code{gcc},

@example
gcc -static example.o -lool -lgsl -lgslcblas -lm
@end example

@node Compatibility with C++
@section Compatibility with C++
@cindex C++, compatibility
The library header files automatically define functions to have
@code{extern "C"} linkage when included in C++ programs.


@node Aliasing of arrays
@section Aliasing of arrays
@cindex aliasing of arrays
The library assumes that arrays, vectors and matrices passed as
modifiable arguments are not aliased and do not overlap with each
other, as well as GSL does. This removes the need for the library to
handle overlapping memory regions as a special case, and allows
additional optimizations to be used.  If overlapping memory regions
are passed as modifiable arguments then the results of such functions
will be undefined.  If the arguments will not be modified (for
example, if a function prototype declares them as @code{const}
arguments) then overlapping or aliased memory regions can be safely
used.

@node Thread-safety
@section Thread-safety

The library can be used in multi-threaded programs.  All the functions
are thread-safe, in the sense that they do not use static variables.
Memory is always associated with objects and not with functions.  For
functions which use @dfn{workspace} objects as temporary storage the
workspaces should be allocated on a per-thread basis.  For functions
which use @dfn{table} objects as read-only memory the tables can be used
by multiple threads simultaneously. Table arguments are always declared
@code{const} in function prototypes, to indicate that they may be
safely accessed by different threads.
